HFL(Z)のための妥当性自動検証手法 という研究の内容を説明します。


## 目的
本研究の目的は、整数拡張された高階不動点論理であるHFL(Z)の自動妥当性検証手法の確立です。
これが重要な理由は、高階プログラムの多くの検証問題は、HFL(Z)の妥当性検証問題に帰着できるためです。
これにより、広いクラスの検証問題を統一的に検証することができます。


## HFL(Z)の構文
まず、HFL(Z)という論理を説明します。
構文はこのようになっており、通常の論理式と変数に加えて、整数の式、プリミティブな述語があります。
また、ラムダ計算と同様に、関数抽象と関数適用があります。
そして特徴的な点として、最小不動点と最大不動点があります。最小不動点は X=ファイとなる最小のXを意味します。最大不動点も同様に、X=ファイとなる最大のXを意味します。
ここで、順序はfalseのほうがtrueより小さいと定義します。したがって、例えば muX.Xという式の意味は、X=Xとなる最小のXなので、falseになります。同様に、nuX.Xの式の意味は、X=Xとなる最大のX、つまりtrueになります。

###
今後は、論理式をHESという表記で表します。
例えば、このHFL(Z)の式をHESで表記するとこうなります。
イメージとしては、関数型プログラムにおける関数定義に近いです。
不動点の部分を等式として切り出して、不動点の中の赤の式を等号の右辺とし、また、不動点で束縛された変数P、引数y、不動点の種類ミューをこのように表記します。

###
例として、このような式を考えます。この2行がHFL(Z)式です。xは自由な整数変数です。
これを関数型プログラムのように考えると、ここで再帰的に現れるPに、このPの定義の本体を代入しても意味は同じです。
そこで、代入して、ベータ簡約すると、このようになります。
すると、再びPが再帰的に現れるので、このPの定義を代入すると、こうなります。
直感的には、このように不動点で定義された式の意味は、このような展開を無限に繰り返した式と等価になります。
ここで、各節の整数を移項するとこうなって、この式は、yが0以上の整数であればtrueになるので、結局yが0以上のときにtrueになる述語になります。


## プログラム検証からHFL(Z)妥当性検証への帰着の例
次に、本研究の意義を説明するために、高階プログラムの検証問題からHFL(Z)の妥当性検証問題への帰着の例を説明します。
詳しくは説明しませんが、このsumという関数を用いているプログラムPが、任意の引数xに対して常に停止するという性質を検証するという問題は、
このようなHFL(Z)式の妥当性検証問題に帰着できます。
言い換えると、プログラムが性質を満たすということと、このHFL(Z)式が妥当であることが同値です。よって、式の妥当性検証によってプログラム検証が行えます。

### 
このようなHFL(Z)への帰着を用いることの利点は、様々な性質の検証が統一的に可能であることです。
既存の高階プログラム検証手法では、検証する性質ごとに別々の手法を用いていました。
しかし、これらの性質をHFL(Z)妥当性検証問題に帰着すると、本研究の妥当性検証器を用いて、このような様々な性質を統一的に検証ができます。


## HFL(Z)自動妥当性検証器 (HFL(Z)ソルバ) の構成
次に本研究の提案手法を説明します。
まず、HFL(Z)の自動妥当性検証器、すなわちHFL(Z)ソルバの構成を説明します。
HFL(Z)ソルバは本研究以前には存在しませんが、ニューHFL(Z)という、最小不動点を含まないフラグメントの論理に対するソルバは存在します。そこで、そのソルバを利用します。
まず、HFL(Z)の式を、 ニューHFL(Z)の式で近似します。この近似は、近似後の式がtrueならば、元の式もtrueになるようにします。
例えば、先ほどのこの式はここに最小不動点を含んでいますが、この式の最小不動点を除去した式で近似します。
その後、ニューHFL(Z)の式を既存のソルバで解き、その結果が妥当、つまり恒真のときは、元のHFL(Z)の式も妥当であると判定します。
妥当でないときは、近似の精度を上げて再度実行して、検証が成功するまでループを繰り返します。
なお、これだけでは式が妥当であることしか判定できないため、元の式の否定をとった式を同じように検証して、否定の式が妥当であれば元の式は妥当でないと判定します。


## 提案するHFL(Z)の近似手法
本研究で提案する手法は3つあり、
1つ目は、一階の近似手法をHFL(Z)へ一般化することで、HFL(Z)の近似の基本となる手法を提案します。
また、近似の改良のために、高階引数の情報を表す整数引数を追加する変換と、不要引数除去による式の簡単化の手法を提案します。


## HFL(Z)の近似
まずHFL(Z)の近似の基本手法を説明します。
方針は、最小不動点を、不動点の有限回の展開で近似するというものです。
有限回の展開をするのは、1階の論理式に対する既存の近似手法のアイデアを用いています。
まず、このような最小不動点で定義された式を考えます。ファイPは、Pを含む式を表します。
アイデアとしては、この式の不動点を有限の回数k回展開して、最後にfalseを代入した式にすることで近似を行います。

これはどういうものかというと、例えば、このPの1回の展開というのは、この式 y=0\/P(y-1)の、Pに任意の値に対してfalseを返す述語を代入した式、つまり、y=0となります。
また、Pの2回の展開は、この2行目の式のPに、任意の値に対してfalseを返す述語を代入した式、y=0\/y-1=0 となります。
Pの3回の展開も同様にして、y=0\/y-1=0\/y-2=0となります。
アイデアはこのように展開するのですが、kは定数でなく、変数に依存する回数にしたいため、静的にこのように展開はできません。

### 
そこで、この展開した式を最大不動点を使ってこのように表現します。
展開回数を表す引数rが追加されており、不動点の展開のたびにrを1ずつ減少させて、rが0になったらここでfalseになって展開を終了します。展開回数として、最初に整数kが与えられています。
 先ほどのこの式を最大不動点を使って展開を表現すると、このようになります。これはk=2のときです。
実際にこの式がPの2回展開の式と同じになることを確かめます。
まずこの式を考えると、ここでP’の第1引数に2を与えているので、ベータ簡約によって、P'の定義の式のrに2を代入して、計算すると、こうなります。
ここで再帰的に現れているP’には1を与えているので、同様にベータ簡約するとこうなります。
さらにP'をベータ簡約すると、今度はrが0なので、このr>0の部分がfalseになり、展開が終了します。
これは、Pを2回展開した式と同一のものです。
このように、最大不動点を使って、展開を表現できます。
次に、展開回数kの決め方を説明します。

###
kはスコープにある整数変数の絶対値の線形結合とします。
つまりx1,x2,...を有限個の自由変数とすると、正の整数定数c,dを用いてこのような形にします。
c,dは、まず小さな値にします。そして、そのc,dを用いて近似した式が妥当でないときは、展開回数が足りなくて早い段階でrが0になってfalseになっている可能性があるので、c,dを増加させて再度近似をします。これによって、展開回数が増加し、近似の精度が向上します。
つまり、先ほどの検証フローで、妥当でないときに近似の精度を上げるというのが、c,dを増加させるということに対応します。
この式の場合だと、cとdを1、つまり|y|+1を展開回数kとすれば、元の述語Pと同じ意味になるため、近似後の式が妥当になり、検証が成功します。

###
では次に、この式の妥当性を考えてみます。
Pは先ほどと同じ式でx>=0のときにtrueを返す述語なので、Qの本体は任意のxに対してtrueになります。
よって、この式全体は真です。
この式を近似するとこのnuHFL(Z)式になりますが、係数c,dが1以上であればこのP’の部分は元のPと意味は変わらないので、 この式も妥当となり、検証が成功します。

以上が近似の基本手法ですが
それではうまくいかない場合があり、改良が必要になるので、その点を説明します。
先ほど示したように2つ改良を提案しましたが、ポスターのスペースの都合上、1つ目のみを説明します。


## 問題点
問題点は、高階引数が存在する場合に、高階引数の情報が、近似の展開回数の式に使える形式で渡されないことです。
例えばこの式を考えます。
このPは先ほどと同様に、mが0以上のときにTrueになる述語で、式全体は恒真になります。
ただし、渡されている値が整数ではなくて、高階関数です。
この式を先ほどの手法で近似することを考えます。
先ほどはこのように展開回数の式で整数変数xを使えたので必要なx+1回の展開回数を得られましたが、
この式ではここでスコープにあるのが高階の変数であるfだけです。
なので、このままでは高階引数の情報が展開回数に反映できず、必要な展開回数を得られません。

###
この解決策として、高階引数の情報を表す整数引数を追加します。「整数引数を追加」というアイデアは、海野らによる高階プログラム検証手法に着想を得ています。
具体的には、この式に対して、赤字の部分を追加します。
Qに整数引数sが追加され、そこに整数mを使った線形結合の式を渡します。
これにより、Pを近似する際の展開回数の式を、追加されたsを使ってこのように作れます。
c’,d’を正の整数とすると、sにはm以上の値が渡されるので、ここが必要なm+1以上の値になるため、適切に近似することができます。

###
c’,d’の決め方は、近似の際の展開回数の式の係数c,dと同様に、まず小さい値で変換と近似を行い、nuHFL(Z)ソルバで解きます。
その結果が妥当でない、つまり検証フローのこの矢印ならば、c’,d’の値を増加させます。
これによって、追加引数sの値が増加します。すると、展開回数の係数c,dは正の値なので、sを使っている展開回数の式の値も増加して、近似の精度が増します。
あとは結果が妥当になるまでループを繰り返し、そのたびにc’,d’を増加させます。
このような追加引数の式の決め方は、海野らによる手法と異なり、より単純で自動化しやすいものになっています。

## 実装と実験
次に、実装と実験の結果を述べます。
提案手法に基づいてHFL(Z)ソルバを実装しました。
実験としては、まず既存の高階プログラム検証手法との比較を行いました。
既存研究の4種類の検証問題に加えて、
そのうちの2つについて、プログラム中の整数を高階関数に変換したものを独自に用意しました。これらは赤でプロットしています。
結果のグラフで、縦軸が既存手法、横軸が提案手法の実行時間です。
両方の手法で解けたインスタンスについては、全体的には対角線より上、つまり提案手法のほうが早いものが多かったです。
解けたインスタンス数は、既存研究が53、提案手法は72で、特に赤の「高階」インスタンスのほとんどは提案手法でのみ解けました。
これは、整数引数の追加の効果です。
  これらのことから、本研究の手法は、既存研究を上回る性能だとわかりました。また、既存研究では4つの性質に対してそれぞれ別々の手法を用いていたものを、本研究では統一的な手法で検証できるという利点があります。

###
次に、不要引数除去の最適化の効果を確かめるため、その有無で実行時間を比較しました。
実験対象は、解くために追加引数が必要なインスタンスです。
結果はこのグラフで、最適化無しの青より、最適化ありのオレンジのほうが1個を除いて実行時間が減少しています。
また、追加引数の数は、すべてのインスタンスにおいて最適化で半分以下に減少しました。
これらのことから、最適化の効果があったと考えています。

## 関連研究
次に関連研究です。
本研究では、一階の論理式に対する近似手法を、高階の式に拡張しました。
また、整数引数の追加は、海野らによる高階プログラムの検証手法に着想を得ています。
一方で、追加引数の式は、HFL(Z)の追加引数の性質を用いて、より単純な方法で決定していて、自動化に向いています。

## まとめ
まとめです。
本研究では、HFL(Z)ソルバの実現のために、HFL(Z)の近似手法とその改良を提案し、ソルバの実装と実験をしました。
今後の課題としては、さらなるソルバの改善があります。
以上で発表を終わります。
